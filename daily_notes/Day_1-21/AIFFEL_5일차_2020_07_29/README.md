# AIFFEL_5일차 2020.07.29

Tags: AIFFEL_DAILY_OLD

### 일정

1. 코드마스터 과제 진행
2. 딥러닝 풀잎스쿨 : cs231n Lecture 3
3. LMS F3,F4

### 딥러닝 풀잎스쿨 : cs231n Lecture3

[CS231n 2017 lecture3](https://www.notion.so/CS231n-2017-lecture3-a167e077f2ea4a8aaf59fd0a508013cf)

# [F-3]파이썬으로 코딩 시작하기

입력값이 여러 개일 때도 각 입력값마다 기본값을 지정해줄 수 있습니다.

단, 이 경우 기본값이 있는 인자들이 기본값이 없는 필수 인자들의 뒤에 와야 합니다.

```jsx
def say_hi_couple_default(name1, name2='nobody'): print(name1 + ', ' + name2 + ' 안녕!')
```

### NoneType

```
def get_mobile_phonenum(value):
    if len(value) >= 11:     # 010XXXXYYYY 의 길이는 11 이상return new PhoneNumber(value)

```

여러분들이 어떤 스트링 value로부터 모바일 전화번호 유형의 객체를 구하는 메소드를 위와 같이 짰다고 합시다. 그런데 저 **코드를 돌리는 도중에** value에 10자리 숫자가 입력되었다고 합시다. 그 순간 에러를 내면서 프로그램이 죽어야 할까요? 아니면 NoneType 객체라도 리턴하는게 좋을까요?

이것은 인터프리터 언어인 파이썬의 설계사상과 관련이 있습니다. 컴파일 타임에 모든 유형이 다 정의되어야 하는 C같은 언어는 NoneType을 필요로 하지 않습니다. 정의될 수 없는 어떤 것이 나온다면 컴파일 오류를 내면 되니까요. 하지만 어떤 것의 유형이 런타임에 정의되어도 무방하다거나, 심지어 **늦게 정의될 수록 좋다고 생각하는 파이썬 같은 언어**는 **`NoneType`** 유형을 필요로 하게 됩니다.

어쨌거나 휴지심조차 없는 일은 종종 일상생활 런타임에서는 발생하니까요.

문자열 안에 쌍따옴표랑 따옴표를 둘 다 쓰고 싶다면? 욕심이 많으시군요.🤭

문자열 안에서 따옴표 앞에 **`\`**를 붙여서 이건 코드 상의 기호가 아닌, 문자 그대로로 해석하라고 표시(escape)할 수 있습니다.

```jsx
print('Quote(\') and double quote(\")')
```

여러 줄을 쓰고 싶다면 따옴표나 쌍따옴표 대신, 따옴표나 쌍따옴표를 세 개씩 연달아 써서 열고 닫아주면 됩니다.

```jsx
print("""Line 1Line2""")
```

remove() 알아서 찾아서 지워주는구나

```jsx
list_123 = [1, 2, 3,4]
list_123.remove(4)
print(list_123)
// [1,2,3]
```

### list 를 사용하지 않고 tuple 을 사용하는 경우와 이유

기술적인 차이는 가변성, 불가변성인데... 문화적 차이??

[출처]([https://edykim.com/ko/post/python-list-vs.-tuple/](https://edykim.com/ko/post/python-list-vs.-tuple/))

문화적인 차이점을 살펴보자. 리스트와 튜플을 어떻게 사용하는지에 따른 차이점이 있다. 리스트는 단일 종류의 요소를 갖고 있고 그 일련의 요소가 몇 개나 들어 있는지 명확하지 않은 경우에 주로 사용한다. 튜플은 들어 있는 요소의 수를 사전에 정확히 알고 있을 경우에 사용한다. 동일한 요소가 들어있는 리스트와 달리 튜플에서는 각 요소의 위치가 큰 의미를 갖고 있기 때문이다.

디렉토리 내에 있는 파일 중 `*.py`로 끝나는 파일을 찾는 함수를 작성한다고 가정해보자. 이 함수를 사용했을 때는 파일을 몇 개나 찾게 될 지 알 수 없다. 그리고 동일한 규칙으로 찾은 파일이기 때문에 항목 하나 하나가 의미상 동일하다. 그러므로 이 함수는 리스트를 반환할 것이다.

다른 예를 확인한다. 기상 관측소의 5가지 정보, 식별번호, 도시, 주, 경도와 위도를 저장한다고 생각해보자. 이런 상황에서는 리스트보다 튜플을 사용하는 것이 적합하다

```jsx
>>> denver = (44, "Denver", "CO", 40, 105)
>>> denver[1]
'Denver'
```

*namedtuple

```jsx
>>> from collections import namedtuple
>>> Station = namedtuple("Station", "id, city, state, lat, long")
>>> denver = Station(44, "Denver", "CO", 40, 105)
>>> denver
Station(id=44, city='Denver', state='CO', lat=40, long=105)
>>> denver.city
'Denver'
>>> denver[1]
'Denver'
```

### dict

```jsx
conductor = {'first_name': '단테', 'last_name': '안'}
for key, value in conductor.items():
    print(key + ' : ' + value)
```

### Memoization

```jsx
memory = {1: 1, 2: 1}

def fibonacci(n):
    if n in memory:
        number = memory[n]
    else:
       number = fibonacci(n-1) + fibonacci(n-2)
       memory[n] = number
    return number

print(fibonacci(100))

print(memory)
```

프로그래밍에서 이렇게 중간 계산값을 기억해놓고, 다시 계산하는 대신 값을 바로 읽어 쓰는 방식으로 계산 시간을 줄이는 기법을 메모이제이션(memoization) 이라고 합니다.

# [F-4] 터미널로 배우는 리눅스 운영체제

- 까만 화면으로 들어가기: **`Ctrl+Alt+F3`**
- GUI로 돌아오기: **`Ctrl+Alt+F1/F2/F7`** 중 하나. 어떤 것이 작동하는지 확인해 보세요!

```jsx
june@juneoh-ubuntu:~$
```

마지막 $는 현재 로그인한 사용자가 일반 사용자임을 나타냅니다. 나중에 배울 최고 관리자 계정(root)의 경우에는 #로 표시됩니다.

**`all`**은 **`-a`**로 줄여서 쓸 수도 있다는 점을 알았습니다. 추가로 다음 인자들도 눈여겨보면 좋습니다.

- **`-l`**: 각 파일 및 폴더의 권한, 소유자, 크기, 수정일시 등 자세한 정보를 출력합니다.
- **`-h`**: 파일 크기를 바이트 수 대신 사람이 알아볼 수 있는 단위(1K, 234M, 2G 등)로 표시합니다.
- **`-t`**: 파일 수정시간 순으로 정렬해서 출력합니다. 최신 파일이 위쪽으로 표시됩니다.
- **`-r`**: 정렬 순서를 뒤집어 출력합니다. **`-rt`**의 형태로 쓰면 최신 파일이 아래쪽으로 표시되어 유용할 때가 있습니다.

한 글자 인자를 여럿 쓸 때에는 서로 붙여 쓸 수 있습니다. 즉, **`ls -l -a -h`**는 **`ls -lah`**로 쓸 수 있습니다.

### 커널

운영체제의 내부는 알맹이인 커널(kernel)과 껍데기인 셸(shell)로 이루어져 있습니다. 우분투의 커널은 리눅스이고, 마이크로소프트 윈도우(Windows)의 경우 2000 이후의 버전은 Windows NT라는 커널을 사용하며, 맥 OS(macOS)의 경우에는 XNU(XNU is Not Unix의 약자)라는 커널을 사용합니다.

리눅스 커널 또한 유닉스와 관련이 깊은데, 1991년 핀란드에서 당시 컴퓨터 공학과 학생 리누스 토발즈(Linus Torvalds)가 유닉스의 무료 및 공개 버전을 지향하여 만든 것이 리눅스입니다. 여기서 명심할 점은 리눅스가 그 자체로 운영체제가 아니라, 운영체제를 위한 커널이라는 사실인데, 우리가 흔히 리눅스 운영체제라 부르는 것들은 사실 이 리눅스를 커널로써 사용하는 운영체제들을 가리키며, 우분투나 Android, ChromeOS 말고도 Debian, CentOS, Red Hat Enterprise Linux 등 다양한 종류가 있습니다.

GUI 셸의 경우, 윈도우에는 우리에게 친숙한 시작 버튼을 포함하는 셸을 Windows shell이 라 부르고, 맥 OS의 경우는 Aqua라는 이름을 갖고 있습니다. 리눅스 계열 운영체제는 GNOME, Unity(동명의 게임 엔진과는 별도의 프로그램) 등이 있지만, 단독으로 동작하기보다 보통 Xorg 등 다른 종류의 프로그램들과 함께 사용됩니다.

### Process, Thread

*프로세스는 운영체제가 메모리를 할당하는 **작업단위**라면, 스레드는 프로세스가 할당받은 메모리를 활용하는 **실행단위**입니다.*

*하나의 프로그램 안에서 여러개의 프로세스를 활용하는 것을 **멀티프로세싱(Multiprocessing)**, 하나의 프로세스 안에서 여러개의 스레드를 활용하는 것을 **멀티스레딩(Multithreading)**이라고 합니다.*

### Terminal??

Ctrl+Alt+F3 및 F2을 눌러 접근했던 화면이 각각 3번 터미널(/dev/tty3) 및 2번 터미널(/dev/tty2)입니다. 우분투에서는 18.04부터 로그인한 사용자의 그래픽 환경을 2번 터미널에 붙여두기 때문에, 우리는 CLI 셸(tty3)에서 무사히 GUI 셸(tty2)으로 귀환할 수 있었습니다. 즉, 터미널이란 컴퓨터에 정보를 입력하고 출력하는 소프트웨어 및 하드웨어로써의 장치이며, 지금도 우리는 하나의 터미널(tty2)이라는 창구를 통해 컴퓨터 안의 세상을 그래픽으로써 들여다보고 있는 것입니다.

### System call

프로세스 관리는 운영체제의 고유 권한이기 때문에, 우리는 커널의 도움이 필요합니다. 우리가 CLI 셸에 **`kill`** 명령어를 입력하는 순간, 셸의 프로세스는 커널에게 이 명령을 전달하고, 커널은 권한 등을 확인한 후에 이를 수행합니다. 이렇게 프로세스가 커널에게 요청을 전달하는 기능을 **시스템 콜(system call)**이라고 합니다. 즉, 시스템 콜은 운영체제의 커널이 프로그램에 제공하는 인터페이스이며, 프로세스가 직접 할 수 없는 프로세스 제어(**`kill`** 등), 파일 조작(폴더 생성 **`mkdir`**, 파일 읽기 **`read`** 등), 장치 및 자원 관리, 네트워크 통신 등을 가능케 합니다. 반대로 보면, 각 프로세스는 커널을 통하지 않고서는 파일이나 장치, 또는 다른 프로세스에 간섭할 수 없다는 뜻이 됩니다.

참고로 **`kill`**은 그 자체로 프로세스를 죽이는 명령이 아니라, 프로세스에 신호를 보내는 명령어입니다. 강제종료하는 **`KILL`** 외에도, 프로그램 실행 중에 **`Ctrl+C`**를 누르면 전달되는 **`INT`** (interrupt) 신호나, 프로세스를 종료하기 전에 해당 프로세스에게 해명할 기회를 주는 **`TERM`** (terminate) 신호도 있습니다.

### PATH

즉, 우리가 셸에 명령어를 입력하면 셸은 일단 셸 내에서 정의된 명령인지 확인합니다. 만약 셸에 정의된 명령 중 있다면, 그대로 명령을 실행합니다. 셸에 정의된 명령이 아니라면, 설치된 프로그램 중에서 해당 이름을 가진 프로그램이 있는지 확인하여 실행합니다. 그럼 해당 이름을 가진 프로그램이 실제로 설치되어 있는지는 어디서 확인할까요? echo $PATH라고 입력하여 한번 물어봅시다.

셸에서 단어 앞에 $가 붙으면 환경 변수(environment variable) 를 의미합니다. 파이썬의 변수처럼, 환경 변수는 운영체제가 프로세스 단위로 사용하는 변수입니다. 즉, 우리가 echo $PATH는 PATH라는 이름의 환경 변수($)의 값을 출력(echo)하라는 뜻입니다.

PATH 환경 변수는 셸이 프로그램을 실행할 때 참조할 경로들을 나타냅니다. 값을 보면 디렉토리 여러 개가 :로 구분되어 있는 것을 알 수 있는데, 만약 동일한 이름의 프로그램이 여러 디렉토리에 설치되어 있다면, PATH 내 순서 상 앞에 있는 디렉토리의 프로그램을 실행합니다.

### 사용자와 권한

유닉스 계열 운영체제에서 모든 권한은 사용자를 기준으로 인증합니다. 운영체제에서 어떤 작업을 실행하기 위해서는 어떤 사용자 이름으로 실행할지 미리 정해져 있어야 한다는 뜻입니다.

```jsx
chown: 대상 파일의 소유 사용자와 그룹을 변경합니다.
```

*권한 표기

drwxr-xr-x라고 무언가 적혀있는데, 이 부분이 바로 권한을 표기하는 부분입니다. 첫 글자인 d는 해당 파일이 디렉토리인지 또는 일반 파일인지 여부를 나타냅니다. 그 뒤를 잇는 글자들은 각각 3 글자씩 소유 사용자, 소유 그룹, 기타 사용자에게 허용된 읽기(read, r), 쓰기(write, w), 실행하기(execute, x) 권한을 나타냅니다.

참고로 실행하기(x)의 경우 프로그램이라면 실제 실행할 수 있다는 것을 나타내지만, 디렉토리의 경우 해당 폴더 안으로 cd로 이동할 수 있는지 여부를 나타냅니다.

chmod 명령어를 사용하면 권한을 변경할 수 있습니다.

### 클라우드와 가상화

가상화(virtualization) 는 이처럼 하나의 컴퓨터를 쪼개어 여러 대의 컴퓨터가 있는 것처럼 사용하게 하는 기술입니다. 가상화에서 실제 물리적인 서버를 호스트(host), 그 안에서 돌아가는 가상 서버를 게스트(guest) 라고 합니다.

가상화에는 여러 가지 종류가 있습니다. 가상머신(Virtual Machine) 가상화의 경우 게스트 자체에 운영체제가 돌아가지만, 컨테이너(Container) 가상화 의 경우, 마치 화장실과 주방을 공유하는 것처럼, 게스트들이 호스트의 운영체제 커널을 공유합니다. 물론 커널의 기능만 공유할 뿐, 프로세스나 자원 등은 서로 철저히 격리하여 서로 간섭할 수 없도록 하는 것이 핵심기술입니다.

도커(Docker) 는 이런 컨테이너 가상화를 손쉽게 제공하는 프로그램입니다. 한 곳에서 실행 환경(우분투 버전, 라이브러리, 필요한 프로그램들)을 컨테이너로 구성해놓은 다음에 그걸 그대로 클라우드로 가져가서 실행하거나, 굳이 클라우드가 아니어도 내 컴퓨터에서 여러 개의 독립된 작업 환경을 구분하는 데에 사용할 수 있습니다.

### Shell 팁

Ctrl+A, Ctrl+E를 통해 명령어의 앞, 뒤로 커서를 이동할 수 있습니다.

실수로 Ctrl+z를 눌러 프로세스를 중지시켰다면, fg를 통해 다시 재개시킬 수 있습니다.

맨 위의 #!/bin/bash 는 이 스크립트 파일을 실행할 때 어떤 프로그램을 사용해야 할지 알려줍니다.

```jsx
#!/bin/bash
#!/usr/bin/python
```

또한 실제로 이 파일을 실행하기 위해 해당 파일에 **`chmod`**로 실행 권한을 추가해야 합니다.

```
june@juneoh-ubuntu:~$ chmod +x test.sh
```

또는 **`|`**를 통해 앞의 명령어의 결과를 입력으로 받아 이어서 처리할 수 있습니다. 예를 들어 아래와 같은 내용의 텍스트 파일(**`fruits.txt`**)이 있다면,

```
Orange
Apple
Grape

```

다음 명령을 통해 순서를 정렬할 수 있습니다.

```
june@juneoh-ubuntu:~$ cat fruits.txt
Orange
Apple
Grape
june@juneoh-ubuntu:~$ cat fruits.txt | sort
Apple
Grape
Orang
```

- 👌**`fg`**: 배경에서 실행되는 작업을 전경(foreground)으로 가져옵니다.👌**`bg`**: 작업을 배경(backgound)으로 보냅니다.👌**`jobs`**: 전경 및 배경 작업의 목록을 표시합니다.

## 연습문제

1. 이름이 **`--all`**인 폴더를 만들어봅시다.

    ```
    mkdir -- --all
    ```

2. ~~titanic.csv~~  train.csv에서 남성과 여성이 몇 명인지 세어봅시다. 우선 **`tail`** 을 통해 첫 줄을 제외한 나머지 줄을 출력하고, **`cut`**으로 성별이 들어있는 열만 추출한 다음, ④로 뭔가 쓱싹 한 다음에 **`uniq`**로 각각 세어봅시다.

    ```
    tail -n +2 train.csv | cut -d, -f6 | sort | uniq -c
    ```

3. titanic.csv에서 성이 Brown인 사람이 몇 명인지 세어봅시다. 성이 아닌 나머지 이름에 Brown이 들어가는 경우도 있으니 조심해야 합니다.

    ```
    cat train.csv | grep "Brown,$()" | wc -l
    // 성이 Brown 이라면, Brown 뒤에 comma(,) 가 바로 오기 때문에, 그걸로 구분
    ```

### 코딩마스터 문제풀이

2번 : 전기버스 

3번 : 카드