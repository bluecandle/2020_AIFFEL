# AIFFEL_7일차 2020.07.31

Tags: AIFFEL_DAILY

### 일정

1. [F-5] 머신러닝의 기본 아이디어
2. 코딩마스터 session 2 문제풀이 : [https://programmers.co.kr/learn/courses/30/parts/12198](https://programmers.co.kr/learn/courses/30/parts/12198)
3. 풀잎스쿨 - 나만의 글쓰기 : 일주일간 배운, 기록한 내용 정리

# [F-5] 머신러닝의 기본 아이디어

---

### **학습 내용**

---

1. 인공지능의 시작과 역사
2. 머신러닝 "Paradigm Shift"
    - 머신러닝 Paradigm Shift - Rule
    - 머신러닝 Paradigm Shift - Workflow
    - 머신러닝 Paradigm Shift - Feature from data
3. 미분과 머신러닝
    - 시스템과 미분
    - 파이썬 미분 구현
    - 머신러닝과 미분

추론은 사고 과정을 기호로 표현함으로써 어떻게 결론에 도달했는지를 보는 과정이고, 탐색은 경우의 수를 찾는 것입니다.

하지만 컴퓨터의 역사란 본질적으로는 튜링이 생각했던 아주 간단한 아이디어였던 배우고 흉내내는 기계를 만들기 위해 먼 길을 돌아온 과정일지도 모릅니다.

머신러닝을 이용한 문제 해결과 프로그래밍을 이용한 문제 해결은 "문제를 해결한다"는 행위가 동일하지만 그 접근법 사이에 상당한 패러다임의 변화가 있습니다.

### 머신러닝의 개념적 이해

머신러닝이란 명시적 프로그래밍 없이 컴퓨터가 학습하는 능력을 갖추게 하는 연구 분야라는 것이죠.

사람이 개입하지 않고도 기계가 스스로 분류 기준을 찾을 수 있으려면 어떻게 해야 하나요? 튜링에 따르면 바로 흉내를 내는 수밖에 없을 것입니다.

### 일반적인 프로그래밍과 머신러닝의 비교

프로그래밍을 통해 주어진 Rule에 따라 입력 Data를 처리하여 정답 Answer를 구하는게 전통적인 프로그래밍이었다면,머신러닝은 입력 Data가 주어졌을 때 어떤 정답을 제시해야 하는지 흉내낼 수 있도록, 인위적으로 케이스를 나누어 각각의 케이스에 대한 답을 구하지 않고 수많은 정답과 입력 데이터 사이에서 **패턴과 규칙**을 찾아냅니다. 비지도학습의 경우라면 정답을 입력하지 않고 주어진 데이터들 사이의 패턴과 규칙을 찾게 됩니다.

이런 방식으로 기계가 스스로 Rule을 찾는 것을 학습(training) 단계라고 한다면, 이렇게 찾아낸 Rule을 적용해 입력 Data에 대한 정답 Answer를 추론(Predict, Infer)해 내는 과정은 전통적인 프로그래밍 방식과 마찬가지가 될 것입니다.

![AIFFEL_7%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8E%E1%85%A1%202020%2007%2031%2094205b1d00c64b7c87cce6211b2d188c/Untitled.png](AIFFEL_7%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8E%E1%85%A1%202020%2007%2031%2094205b1d00c64b7c87cce6211b2d188c/Untitled.png)

. 후대에 여러 개의 뉴런들을 만들고(뉴럴 네트워크) 그것을 역전파법(Back Propagation)을 이용해 학습하는 것이 가능해졌는데 이를 딥러닝이라고 합니다.

### 머신러닝의 7단계

---

data collection
data preparation : 훈련을 위한 상태로 만들기 ( 이 과정에서 데이터 관찰을 통해 수집된 데이터의 적합성을 평가하기도 하고, 데이터를 용도별로 나누기도 한다. )
choosing a model
training ( 더 좋은 예측을 하는 Weight 와 bias vector 를 만들어낸다 )
evaluation ( train 에 사용되지 않은 데이터를 사용하여 prediction 이 어떻게 이루어질 것인지! 모델이 잘 학습되었는지 실제 prediction 전에 확인해보는 과정 )
hyperparameter tuning ( ex. learning rate )
prediction

### 훈련 효과를 증대시키기 위한 방법??

---

Data augmentation techniques such as cropping, padding, and horizontal flipping are commonly used to train large neural networks.
기존 데이터를 아주 조금씩 변형시켜서 새로운 데이터로 인식하도록 만드는 방법을 사용할 수 있고
validation data
훈련 데이터의 일부를 검증 데이터로 사용하여 훈련을 진행하는 과정에서 모델의 학습이 잘 이루어지고 있는지 판단하고 더 나은 학습 방향을 제시할 수 있다.

### 다시 정리

---

어떤 데이터에 대해서 패턴을 찾기 위해서는 *각 문제에 맞는* 머신러닝 모델을 설계해야 합니다.

모델의 설계는 우리가 풀고자 하는 문제의 종류, 입력데이터의 종류, 출력 정답의 형태 등에 따라 달라집니다.

문제정의가 끝났으면 알맞는 머신러닝 모델을 설계합니다. 딥러닝 역시 크게 보면 머신러닝에 포함되니 여기선 굳이 나눠 생각하지 않겠습니다.

머신러닝 모델에는 Regression, Classification, Desicion Tree, 신경망, CNN, RNN, SVM, PCA 계열 등이 있습니다.

모델을 설계했으면 입력 데이터를 넣습니다. 머신러닝의 단계에 따라 훈련 단계에서 입력하는 데이터는 "훈련 데이터", 실제로 모델을 사용하기 위해 추론 단계에서 입력하는 데이터는 "테스트 데이터"라고 부르기도 합니다.

훈련 시간 동안 기계는 우리가 설계한 머신러닝 모델과 입력 데이터를 이용해 패턴을 찾기 위해 훈련(training)합니다.

그리고 훈련을 통해 얻은 규칙을 바탕으로 추론(inference)합니다.

### 모델 훈련이 갖는 의미

---

***"머신러닝 모델이 훈련을 통해 데이터를 학습한다" :*** 데이터로부터 특성(feature)들을 찾아내서 각 데이터들의 특성의 중요도에 따라 가중치(Weight)를 곱하고 훈련을 통해 이 가중치를 찾는다는 의미입니다.

### Feature Extraction

---

특성을 추출한다는 것은 입력된 대상을 있는 그대로 보겠다는 것이 아니라 풀려는 문제에 꼭 필요한 특성만을 추려서 재해석해 보겠다는 뜻이 됩니다.

## 미분

---

### 미분이 갖는 의미

---

입력의 변화량이 극소량으로 변할 때, 출력의 변화량이 어떻게 될까? 이것이 미분입니다. 수식을 사용하면 미분은 다음과 같이 표기합니다.

$f'(x)={\frac  {d}{dx}}f(x)$

어떤 시스템을 설계할 때 우리는 3가지를 중점적으로 설계해야 합니다.

- 입력 조건
- 목표 출력
- 입력이 변할 때 출력이 얼마나 변하는가?

그리고 여기서 미분은 **시스템에서 입력 대비 출력의 관계를 내포하고, 입력이 (미세하게) 변할 때 출력이 얼마나 변하는지를 나타내고 있습니다.**

예시 : 기대수명 예측

---

기대 수명을 구할때 체중, 키, 성별 등 여러 가지를 고려했었죠? 체중이 수명에 더 중요한 영향을 미칠까요, 출생지가 더 영향을 미칠까요? 한 사람의 기대 수명을 늘리기 위해서는 어떤 요소를 바꾸는 것이 가장 효과적일까요? 이때 이 모델에서 **특성 별 "중요도"("가중치")**를 나타내는 것은 바로 **특성량 변화에 따른 기대 수명의 변화량**일 겁니다. 그리고 우리는 미분을 통해 이 변화량을 구할 수 있습니다.

### 파이썬을 통한 미분

---

프로그래밍에서 0으로 근사치를 구할 때 통상 1e-5 정도의 값을 많이 이용합니다.

특히 분모가 0이 될 가능성이 있을 때 분모에 살짝 더해주는 경우가 있지요. 다만 이 값은 매우 작은 값이지만 나중에 이 값이 반복되면 오차가 발생할 수 있으니 경우에 따라 조절하여 사용하면 됩니다.

### 손실함수

---

어떻게 이 손실함수를 최소화할 수 있을까요? 우리가 바꿀 수 있는 것은 가중치 W 뿐입니다. 이때 미분이 사용됩니다.

***이제 우리는 이 손실함수를 가중치 W로 미분할 때 얻어지는 기울기를 단서로 삼을 것입니다.***

[ex] MSE 손실함수

${\displaystyle \operatorname {MSE} ={\frac {1}{n}}\sum _{i=1}^{n}(Y_{i}-{\hat {Y_{i}}})^{2}}$

### 계산 과정

---

- 1단계. 가중치 파라미터가 랜덤하게 초기화된 시작점에서 출발합니다.
- 2단계. 시작점에서의 기울기를 미분을 통해 구해 봅니다. 음의 기울기가 얻어졌습니다. 이것은 가중치를 증가시키면 손실함수가 낮아진다는 뜻입니다.
- 3단계. 가중치를 양의 방향, 즉 손실함수가 줄어드는 방향으로 한 스텝씩 이동합니다. 이 이동하는 보폭의 크기를 학습률(learning rate)라고 합니다.
- 4단계. 손실함수가 거의 줄어들지 않는 지점까지 계속 조금씩 가중치를 이동해 봅니다. 가중치를 이동하는 방향은 현재 위치에서의 기울기 부호와 반대방향입니다.

**그림에서 볼 수 있듯 손실함수의 기울기, 미분값이 0, 최소가 되는 지점에서의 W, b를 찾으면 오차가 최소가 될 것입니다. 이러한 원리로 학습하는 것을 경사 하강법이라고 합니다.**

## 이정도면 충분한가?

---

튜링머신이 가지는 한계점이 하나 있습니다. 그것은 바로 종료조건을 스스로 지정하지 못한다는 점입니다.

이것을 정지문제(halting problem)이라고 합니다. 앨런 튜링은 1936년에 **머신이 모든 가능한 입력값에 대해 정지 여부를 판정할 수 있는 일반적인 알고리즘이 존재하지 않음**을 밝혔습니다.

[https://www.youtube.com/watch?time_continue=431&v=92WHN-pAFCs&feature=emb_logo](https://www.youtube.com/watch?time_continue=431&v=92WHN-pAFCs&feature=emb_logo)

이것이 머신러닝에서는 어떤 의미를 가질까요? 혹시 스스로 Rule을 찾아내는 머신러닝의 방식에서는 스스로 어떤 입력에 대한 종료조건을 스스로 찾을 수 있지 않을까요? 하지만 튜링은 그렇지 않다고 합니다.

종료조건을 알 수 있다는 것은 그 기계 내부의 Rule이 더이상 적용되지 않는 시점, 즉 상황이나 맥락이 변경된 시점을 스스로 판단할 수 있다는 뜻입니다.

하지만 머신러닝은 철저히 데이터에 의존적입니다. 기계에게 털이 까만 고양이 사진만 고양이라고 라벨을 달아 보여주면, 기계 스스로는 털이 까만 고양이의 세계에서 빠져나오지 못하고 완벽하게 오버피팅됩니다. 기계가 경험한 경험 자체에 bias가 있기 때문입니다. 기계가 그 오버피팅의 덫에서 빠져나오게 하기 위해 우리는 Rule을 직접 추가해 줄 수 없습니다. 오직 데이터를 통해서 기계가 털이 하얀 고양이도 존재한다는 것을 스스로 깨닫게 해주어야 합니다.

---

---

# 코딩마스터 session 2 문제풀이

---

[https://programmers.co.kr/learn/courses/30/parts/12198](https://programmers.co.kr/learn/courses/30/parts/12198)

- 가장 큰 수

    문자열 비교연산의 동작방식을 이용한 풀이

    문자열 비교연산의 경우엔 첫번째 인덱스인 666[0]인 6과 101010[0]인 1과 222[0]인 2를 ascii숫자로 바꿔서 비교합니다. 물론 같으면, 다음 인덱스도 비교합니다. 비교한 결과 [6, 2, 10]의 순으로 정렬됩니다.

    ```python
    def solution(numbers):
        numbers = list(map(str, numbers))
        numbers.sort(key=lambda x: x*3, reverse=True)
        return str(int(''.join(numbers)))
    ```

- H-Index

    ```python
    # citation 숫자 배열 안에서 가장 많이 인용된 횟수부터 시작하여, 순차적으로 1씩 감소시켜보며 진행한다.
    # h가 0이 될 때까지 진행하며,h 가 0이 되는 경우 답은 0이 된다. ( 모든 논문이 한 번도 인용된 적이 없음)
    # h 번 이상 인용된 논문들을 골라내고, 골라진 논문들의 수가 h 개 이상이라면, 우선 1단계 통과
    # 단, 골라진 논문들을 내림차순으로 정렬했을 때 h 번째 이후에 있는 대상들을 확인해봐야한다.
    # 해당 대상들이 h 번을 초과하는 인용 횟수를 가졌다면, 조건에 성립하지 않으므로, 다음 h 항목으로 넘어가야 한다.

    def solution(citations):
        answer=0   
        for h in range(max(citations),0,-1):
            # print(h)
            _l = sorted(list(filter(lambda x: x>=h, citations)),reverse=True)
            # print(_l)
            if(len(_l)>=h):
                __l = _l[h:]
                # print(__l)
                answer = h
                for o in __l:
                    if(o>h):
                        answer = 0
                        break
                if(answer):
                    break

        return answer
    ```

# 6.14. Lambdas

Lambda expressions (sometimes called lambda forms) are used to create anonymous functions.

The expression `lambda parameters: expression` yields a function object. The unnamed object behaves like a function object defined with:

```jsx
def <lambda>(parameters):
	return expression
```

---

---

# 풀잎스쿨 - 나만의 글쓰기 : 일주일간 배운, 기록한 내용 정리

---

## Github 블로그를 만들어보자 : Jekyll 을 이용한 github 블로그 만들기

1. 'github.io' 페이지 만들기
    1. <username>.github.io 라는 이름의 repository 를 설정한다
    2. repo의 settings 에 들어가서 github page 라는 항목을 봤을 때, <username>.github.io 라는 이름으로 publish 되었다는 내용이 뜨면 Ok
2. 혹은, 그냥 jekyll 을 통해 먼저 만들고 진행해도 된다.
    1. [https://gmlwjd9405.github.io/2017/10/06/Jekyll-github.io-blog-1.html](https://gmlwjd9405.github.io/2017/10/06/Jekyll-github.io-blog-2.html)
3. 

---

---

# 기타

[데이터 사이언스에 대한 오해](https://blog.ab180.co/data-science-with-r-1-misperception/)

알파고의 성공이후 Hidden layers가 여러 층위로 들어간 Neural Network 모델이 “딥러닝”이라는 이름으로 세간에 알려지면서 요즘 필자가 만나는 고객들은 필자가 얼마나 “딥러닝”을 잘하는 사람인지 물어본다. 필자의 대답은 언제나 같다. 머신러닝 모델들은 이미 오픈 소스로 다 알려져 있다고. 누가 더 “딥러닝”을 잘하냐고 물으실게 아니라, 누가 더 “딥러닝”을 목적에 맞게 잘 쓸 수 있는 사람인지를 물어보셔야 한다고.

한마디로 정리하면, Machine learns. Only if the teacher designs it well.

데이터 분석가는 자동차 수리공, 머신러닝 개발자는 자동차 엔진 개발자, 그리고 데이터 사이언티스트는 자동차 설계 및 디자이너라고. 참고로 여기서 엔진 개발자라는 분은 이미 만들어진 엔진을 차체에 이식시키는 수리공이 아니라, 4기통, 8기통 엔진을 직접 개발하는 엔지니어를 말한다. (한국에 있는 인공지능 기반 상품 회사에서 그런 능력을 갖추신 분을 별로 본 적이 없었다.)

숙련된 자동차 수리공은 자동차를 한번 운전해보고 엔진 소리를 들으면 어느 곳에 문제가 있는지 쉽게 파악해내고 적합한 솔루션을 제시할 수 있다. 머신러닝을 잘 활용하는 능력을 갖춘 개발자는 적절한 엔진을 장착시켜 자동차가 잘 나갈 수 있도록 해 줄 수 있다. 그러나 차를 설계하고 디자인해서 상품을 출시하는 것은 보다 근본적인 문제다. 필자는 데이터 사이언티스트에게 가장 핵심적인 스킬은 문제에 맞는 모델링을 하고 그 모델을 통계학, 시뮬레이션, 머신러닝 기술을 적절하게 조합해서 실제로 구현하는 능력이라고 본다.